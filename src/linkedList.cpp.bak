#include <climits>
#include <iostream>
#include <cassert>
#include "linkedList.h"
//std::atomic<int> numSplits;


ListNode* LinkedList::initialize() {
    OpStruct* oplog = (OpStruct *)PMem::getOpLog(0);

    PMem::alloc(1,sizeof(ListNode),(void **)&headPtr,&(oplog->newNodeOid));
    ListNode* head = (ListNode*)new(headPtr.getVaddr()) ListNode();
    flushToNVM((char*)&headPtr,sizeof(pptr<ListNode>));
    smp_wmb();

    OpStruct *oplog2 = (OpStruct *)PMem::getOpLog(1);

    pptr<ListNode> tailPtr;
    PMem::alloc(1,sizeof(ListNode),(void **)&tailPtr, &(oplog->newNodeOid));
    ListNode* tail= (ListNode*)new(tailPtr.getVaddr()) ListNode();


    pptr<ListNode >nullPtr(0,0);

    head->setNext(tailPtr);
    head->setPrev(nullPtr);
    head->setCur(headPtr);
#ifdef STRINGKEY
	std::string minString= "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
    std::string maxString= "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
    Key_t max;
    max.setFromString(maxString);
    Key_t min;
    min.setFromString(minString);
	head->setMin(min);
    head->insert(min,0,0);
    tail->insert(max, 0,0);
	tail->setMin(max);
    head->setMax(max);
#else
    head->insert(0,0,0);
    head->setMin(0);
    head->setMax(ULLONG_MAX);
    tail->insert(ULLONG_MAX, 0,0);
    tail->setMin(ULLONG_MAX);
#endif

//    tail->setNumEntries(MAX_ENTRIES); //This prevents merge of tail
    tail->setFullBitmap(); 
    tail->setNext(nullPtr);
    tail->setPrev(headPtr);
    tail->setCur(tailPtr);

    printf("sizeof oplog :%d\n",sizeof(OpStruct));
//    printf("headPtr :%p ,oplogs:%p\n",&headPtr, &oplogs)  ;

    flushToNVM((char*)head,sizeof(ListNode));
    flushToNVM((char*)tail,sizeof(ListNode));
    smp_wmb();

/*    
    oplog->op=OpStruct::done;
    oplog2->op=OpStruct::done;
    flushToNVM((char*)oplog,sizeof(OpStruct));
    flushToNVM((char*)oplog2,sizeof(OpStruct));
    smp_wmb();
*/

    return head;
}

bool LinkedList::insert(Key_t key, Val_t value, ListNode* head, int threadId) {
    restart:
    ListNode* cur = head;

    while (1) {
        if (cur->getMin() > key) {
//printf("1 %s %s \n",cur->getMin(),key);
            cur = cur->getPrev();
            continue;
        }
        if (!cur->checkRange(key)) {
//printf("2 %s %s %s\n",cur->getMin(),key,cur->getMax());
//exit(1);
            cur = cur->getNext();
            continue;
        }
        break;
    }

    if (!cur->writeLock(genId))
        goto restart;
    if (cur->getDeleted()) {
        cur->writeUnlock();
        goto restart;
    }
    if (!cur->checkRange(key)) {
        cur->writeUnlock();
        goto restart;
    }

    bool ret = cur->insert(key, value,threadId);
    cur->writeUnlock();
    return ret;
}

bool LinkedList::update(Key_t key, Val_t value, ListNode* head) {
    restart:
    ListNode* cur = head;

    while (1) {
        if (cur->getMin() > key) {
            cur = cur->getPrev();
            continue;
        }
        if (!cur->checkRange(key)) {
            cur = cur->getNext();
            continue;
        }
        break;
    }

    if (!cur->writeLock(genId))
        goto restart;
    if (cur->getDeleted()) {
        cur->writeUnlock();
        goto restart;
    }
    if (!cur->checkRange(key)) {
        cur->writeUnlock();
        goto restart;
    }
    bool ret = cur->update(key, value);
    cur->writeUnlock();
    return ret;
}

bool LinkedList::remove(Key_t key, ListNode *head) {
    restart:
    ListNode* cur = head;

    while (1) {
        if (cur->getMin() > key) {
            cur = cur->getPrev();
            continue;
        }
        if (!cur->checkRange(key)) {
            cur = cur->getNext();
            continue;
        }
        break;
    }
    if (!cur->writeLock(genId)) {
        if (head->getPrev() != nullptr) head = head->getPrev();
        goto restart;
    }
    if (cur->getDeleted()) {
        if (head->getPrev() != nullptr) head = head->getPrev();
        cur->writeUnlock();
        goto restart;
    }
    if (!cur->checkRange(key)) {
        if (head->getPrev() != nullptr) head = head->getPrev();
        cur->writeUnlock();
        goto restart;
    }

    bool ret = cur->remove(key,genId);
    cur->writeUnlock();
    return ret;
}

bool LinkedList::probe(Key_t key, ListNode *head) {
    restart:
    ListNode* cur = head;
    //int count = 0;
    //if(cur->getMin() > key)
    //    std::atomic_fetch_add(&numSplits, 1);

    while (1) {
        if (cur->getMin() > key) {
            cur = cur->getPrev();
            continue;
        }
        if (!cur->checkRange(key)) {
            cur = cur->getNext();
            continue;
        }
        break;
    }

    version_t readVersion = cur->readLock(genId);
    //Concurrent Update
    if (!readVersion)
        goto restart;
    if (cur->getDeleted()){
        goto restart;
    }
    if (!cur->checkRange(key)) {
        goto restart;
    }
    bool ret = false;
    ret = cur->probe(key);
    if (!cur->readUnlock(readVersion))
        goto restart;
    return ret;
}

bool LinkedList::lookup(Key_t key, Val_t &value, ListNode *head) {
    restart:
    ListNode* cur = head;
    int count = 0;
    //if(cur->getMin() > key)
    //    std::atomic_fetch_add(&numSplits, 1);

    while (1) {
        if (cur->getMin() > key) {
            cur = cur->getPrev();
            continue;
        }
        if (!cur->checkRange(key)) {
            cur = cur->getNext();
            continue;
        }
        break;
    }
    version_t readVersion = cur->readLock(genId);
    //Concurrent Update
    if (!readVersion)
        goto restart;
    if (cur->getDeleted()){
        goto restart;
    }
    if (!cur->checkRange(key)) {
        goto restart;
    }
    bool ret = false;
    ret = cur->lookup(key, value);
    if (!cur->readUnlock(readVersion))
        goto restart;
    return ret;
}

void LinkedList::print(ListNode *head) {
    ListNode* cur = head;
    while (cur->getNext() != nullptr) {
        cur->print();
        cur = cur->getNext();
    }
    std::cout << "\n";
    return;
}

uint32_t LinkedList::size(ListNode *head) {
    ListNode* cur = head;
    int count = 0;
    while (cur->getNext() != nullptr) {
        count++;
        cur = cur->getNext();
    }
    return count;
}

ListNode *LinkedList::getHead() {
    ListNode* head = (ListNode*) headPtr.getVaddr();
    return head;
}

uint64_t LinkedList::scan(Key_t startKey, int range, std::vector<Val_t> &rangeVector, ListNode *head) {
    restart:
    ListNode* cur = head;
    rangeVector.clear();
    // Find the start Node
    while (1) {
        if (cur->getMin() > startKey) {
            cur = cur->getPrev();
            continue;
        }
        if (!cur->checkRange(startKey)) {
            cur = cur->getNext();
            continue;
        }
        break;
    }
    bool end = false;
    assert(rangeVector.size() == 0);
	std::vector<Val_t> resultBuffer;
    while (rangeVector.size() < range && !end) {
        version_t readVersion = cur->readLock(genId);
        //Concurrent Update
        if (!readVersion)
			goto restart;
		if (cur->getDeleted())
            goto restart;
//		resultBuffer.clear();
        //end = cur->scan(startKey, range, resultBuffer, readVersion,genId);
        end = cur->scan(startKey, range, rangeVector, readVersion,genId);
        if(!cur->readUnlock(readVersion))
			goto restart;
        cur = cur->getNext();
    }
    return rangeVector.size();
}

bool LinkedList::Recovery() {

    for(int i=0; i<1000; i++){	
        OpStruct* oplog = (OpStruct *)PMem::getOpLog(i);
	PMEMoid oid = oplog->newNodeOid;
	if(OID_IS_NULL(oid)) continue;

	pptr<ListNode> ln;
	ln.setRawPtr(oplog->oldNodePtr);
	ln->recoverNode(oplog);
    }
    
    ListNode* cur = (ListNode*)headPtr.getVaddr();
    int count = 0;
    while (cur->getNext() != nullptr) {
        count++;
        cur = cur->getNext();
    }
    return true;
}
